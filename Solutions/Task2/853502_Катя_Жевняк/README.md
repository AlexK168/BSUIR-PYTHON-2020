Никаких зависимостей не требуется.
 
task 1:  Есть исходный файл, два временных и файл для результата. Сортировка выполняется методом наивного слияния. Результат записывается в result_file.txt

task_2: Ппроверяем, являются ли входные данные list'ом, tuple'ом или dict'ом, если нет, то считаем, что это какой-то класс и переводим его в dict. Далее поочередно проверяем на каждый тип и вызываем нужную функцию. Из json: получаем токен с помощью функции _get_token и вызываем нужную функцию, возвращающую нужный тип

task_3: Переопределены базовые методы (сложение, вычитание и т.д.) для класса Vector.

task_4: Храним значения прошлых вызовов в коллекции cache, где ключ - аргументы, а значение - результат функции. Если есть значение по ключу, возвращаем его, иначе вызываем функцию.

task_5: Юниттесты с помощью unittest и coverage. Покрытие около 90 процентов.

singleton: Реализован в виде класса. От singleton наследуется класс, которому необходим данный паттерн.

setup.py : реализован
