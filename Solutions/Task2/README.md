Написано на python 3.8, но должно работать и на более ранних версиях.
#Запуск программы
1) Скачать и разархивировать прикреплённый архив;
2) Перейти в папку, куда был размещён проект (Для windows cd E:\путь... в командной строке);
3) Установить пакет при помощи компанды python setup.py install;
4) Для запуска тестов необходимо написать python setup.py test;
5) Для запуска показательных скриптов необходимо вводить в командной строке vector, json, decorator, singleton, sorting. 
(Скорее всего sorting не сработает, без понятия, в чём беда).
#Проделанная работа
##1. Vector
Класс реализован на основе списка при помощи переопределения основных стандартных методов:
1) Переопределение _getitem() позволяет получить одну из ячеек вектора по индексу;
2) Переопределение _mul() позволило определить операцию умножения на константу:
3) Переопределение _eq() позволяет сравнивать вектора между собой;
4) Переопределение _add() позволяет складывать между собой вектора одинаковой длины, а также вектор с числом путём прибавления этого числа к каждой ячейке;
5) Переопределение _sub() позволило вычислять разность двух векторов, а также вектора и числа;
6) Переопределение _str() позволяет выводить вектор на экран в виде строки:
Также была написана функция scalar_multiply(self, other), вычисляющая скалярное произведение двух векторов одинаковой длины.
##2. Sort
Реализация данного варианта сортировки во внешней памяти основана на двоичной куче, которая также реализована мной в виде класса HeapqMerging.
Двоичная куча показывает хорошие результаты по скорости, так как первоначальное создание кучи происходит за O(n*log n),
зато каждое последующее получение из кучи минимального элемента происходит за O(log n), а при условии отсортированных 
данных - намного быстрее. Пройдёмся по методам:
1) Метод sort_external(file_path, result_path) принимает в качестве аргументов путь к сортируемому файлу, а также выходной путь.
Здесь производится проверка на существование файла, в противном случае выбрасывается ошибка FileNotFoundError. Далее 
метод вызывает sorting(file_path) и merging(result_path) один за другим;
2) Метод sorting(filePath: str) принимает путь к файлу, считывает из него по 250000 строк, после чего вызывает для полученных
чисел метод sort_and_save(integer_list: list);
3) Метод sort_and_save(integer_list: list) сортирует полученные данные при помощи встроенной функции list.sort(key) , после 
чего создаёт временный файл и помещает генератор intsfromfile() для созданного файла в список ITERS;
3) Метод merging(resultPath: str) создаёт двоичную кучу на основе списка итераторов ITERS, после чего последовательно
записывает минимальные элементы из файлов в файл по пути resultPath.
##3. Singleton
Метод реализован в виде метакласса, переопределяющего стандартный метод _call() таким образом, чтобы при повторной попытке 
создания объекта одного и того же класса был возвращён созданный ранее объект.
##4. Decorator
Класс CacheDecorator создан на основе словаря, который играет функцию хранения предыдущих аргументов вызовов функций.
При очередном вызове функции происходит проверка содержимого словаря на предмет нахождения там результата данной функции
при тех же аргументах. В случае нахождения такого элемента происходит возврат хранимого значения. В ином случае вычисляется
результат данной функции, заносятся данные в словарь, после чего происходит возврат значения.
##5. JSON
Сериализация и десериализация JSON реализована в виде класса. На выходе при сериализации получаем строку, при выводе
которой на экран можно увидеть разграниченное представление исходных данных с отступами для наглядности и простоты.
В тестах проверено, что данное представление строки может быть десериализовано при помощи стандартной библиотеки json, а
сам результат десериализации совпадает с тем, что получается на выходе моей реализации. Рассмотрим некоторые методы:
1) serialize(obj: object) получает на вход некоторый объект и в зависимости от его типа вызывает одну из функций _obj(),
_list() или _dict(), которые и формируют итоговую строку при помощи рекурсивного вызова самих друг друга. Словарь
_typeDict является неким аналогом конструкции switch/case на языке python и используется для более наглядной обработки атрибутов.
2) deserialize(json_str: str) получает на вход строку JSON, после чего при помощи вызова одной из функций _from_obj()
или _from_list() формирует словарь атрибутов на основе входной строки.